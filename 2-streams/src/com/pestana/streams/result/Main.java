package com.pestana.streams.main;

import com.pestana.streams.object.Person;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {

    public static void main(String[] args) {
        List<Person> people = Arrays.asList(new Person("Rodrigo", 34),
                new Person("Deborah", 33),
                new Person("Sonia", 61),
                new Person("Edna", 78));


        //characteristic:
        //1 - The streams API has three main operations: filter, Map and Reduce.

        //2 - we have two process types of Streams: stream and parallelStream.
        //The difference is that one operates one by one (sequence) and
        // the second creates many process (threads generated by the Fork/Join framework (jdk 1.7) to generate these threads with transparency)

        //3 - There are two types of operations: Intermediaries and Terminals.
        // The intermediaries are the operations that return another Stream instance. Example: filter(), mapToDouble(). The operation are linked.
        //The terminals are the operations that returns an object ou value and it closes the Stream. Example: forEach(), sum(), min(), max(), findFirst()
        // If you try to use the stream after that you have an java.lang.IllegalStateException
        //An alternative to use the same stream for terminal operations is to use the class IntSummaryStatistics;

        //4 - There are three special interfaces to operate primitive types: intStream, DoubleStream e LongStream

        //5 - We can convert a stream to collections of List, Set and Map interfaces. You can use the Collectors class for it

        //6 - You can use the Optional class. You can use it only with terminal operations beacuse are them that returns an Optional object

        System.out.println(
                "1 - Filter - Select people that has more than 50 years old and print their names\n"
        );
        Stream<Person> streamPersons = null;
        streamPersons = people.stream();
        streamPersons.filter(p -> p.getAge() > 50).forEach(person -> System.out.println(person.getName()));

        System.out.println("\n--------------------------------------------------------------------------\n");

        System.out.println(
                "2 - Using parallelStream to print the list\n"
        );

        streamPersons = people.parallelStream(); // new stream
        Integer sumAges = streamPersons.filter(p -> p.getName().startsWith("E")).mapToInt(p -> p.getAge()).sum();
        System.out.println("Sum of ages using parallelStream: " + sumAges);

        System.out.println("\n--------------------------------------------------------------------------\n");

        System.out.println(
                "3 - Map all ages and print the smallest\n"
        );

        streamPersons = people.stream(); // new stream
        //using the IntSummaryStatistics class
        IntSummaryStatistics intSummaryStatistics = streamPersons.mapToInt(p -> p.getAge()).summaryStatistics();

        streamPersons = people.stream(); // new stream
        Integer minAge = streamPersons.mapToInt(p -> p.getAge()).min().getAsInt();

        System.out.println("1 - The first option: using the opened stream: " + minAge);
        System.out.println("2 - The second option: using the IntSummaryStatistics class: " + intSummaryStatistics.getMin());

        System.out.println("\n--------------------------------------------------------------------------\n");

        System.out.println(
                "4 - Using interfaces for primitive values\n"
        );

        streamPersons = people.parallelStream(); // new stream
        IntStream intStream = streamPersons.filter(p -> p.getName().startsWith("E")).mapToInt(p -> p.getAge());
        System.out.println("Sum of ages using special interface IntStream: " + intStream.sum());

        System.out.println("\n--------------------------------------------------------------------------\n");

        System.out.println(
                "5 - Converting to collections\n"
        );

        //create a new list with people that the name starts with R
        List<Person> listSelectedPeople = people.stream().filter(p -> p.getName().startsWith("R")).collect(Collectors.toList());
        //create a new Set with people that the name starts with D
        Set<Person> setSelectedPeople = people.stream().filter(p -> p.getName().startsWith("D")).collect(Collectors.toSet());
        //create a new Map grouping people by the Age
        Map<Integer, List<Person>> map = people.stream().collect(Collectors.groupingBy(Person::getAge));

        System.out.println("Printing List Collection");
        listSelectedPeople.forEach(l -> System.out.println(l.getName()));

        System.out.println();

        System.out.println("Printing Set Collection");
        setSelectedPeople.forEach(s -> System.out.println(s.getName()));

        System.out.println("Printing values with key (age) 33 of the Map Collection");
        map.get(33).forEach(p -> System.out.println(p.getName()));


        System.out.println("\n--------------------------------------------------------------------------\n");

        System.out.println(
                "6 - Using the Optional class and its methods\n"
        );
        System.out.println("Trying to get people with more than 100 years old. If there is no one creates a new person with name Bil and age 5");
        Optional<Person> optionalPerson = people.stream().filter(p -> p.getAge() > 100).findAny();
        optionalPerson.ifPresent(person -> {
            Person p = optionalPerson.get();
            System.out.println(p.getName());
        });

        System.out.println(optionalPerson.orElse(new Person("bil", 5)).getName());


    }
}
